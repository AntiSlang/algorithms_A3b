README.md (вы тут) - описание полученных результатов  
293151751 - ID посылки в Codeforces  
A3b_codeforces.cpp - A3b из Codeforces  
A3b_chart.cpp - A3b для формирования файлов с данными (внутри находятся "Реализации классов ArrayGenerator и SortTester")  
chart.py - python-файл для формирования графиков  
1.png - график 1 "Массивы, которые заполнены случайными значениями в некотором диапазоне" (random)  
2.png - график 2 "Массивы, которые отсортированы в обратном порядке по невозрастанию" (reversed)  
3.png - график 3 "Массивы, которые почти отсортированы" (swap)  
random.txt - данные для массивов типа 1 с алгоритмом Quick  
random_hybrid.txt - данные для массивов типа 1 с алгоритмом Intro  
reversed.txt - данные для массивов типа 2 с алгоритмом Quick  
reversed_hybrid.txt - данные для массивов типа 2 с алгоритмом Intro  
swap.txt - данные для массивов типа 3 с алгоритмом Quick  
swap_hybrid.txt - данные для массивов типа 3 с алгоритмом Intro  

Сравнительный анализ:  
### Сравнительный анализ стандартной и гибридной реализаций алгоритма сортировки  
#### 1. Исследование на случайных данных  
- Результаты:  
  - Для случайно сгенерированных массивов разница во времени выполнения между стандартным QuickSort и гибридным IntroSort оказалась минимальной.  
  - Время выполнения обоих алгоритмов стабильно находится в пределах до 6 мс, даже для массивов размером \(10,000\) элементов.  
- Причины:  
  - В случае случайных данных, худший случай для QuickSort маловероятен, так как выбор опорного элемента (пивота) достаточно удачен.  
  - Гибридный IntroSort не прибегает к HeapSort благодаря малой глубине рекурсии и использует InsertionSort только для небольших подмассивов.  
  - Основная работа в обоих алгоритмах заключается в разбиении массива, которое выполняется с одинаковой сложностью \(O(N \log N)\).  
- Вывод:  
  - В условиях случайных данных IntroSort не даёт значительного выигрыша по времени, что делает стандартный QuickSort предпочтительным благодаря его простоте.  

#### 2. Исследование на обратно отсортированных данных  
- Результаты:  
  - В случае обратно отсортированных массивов гибридный IntroSort существенно превосходит стандартный QuickSort.   
  - Время выполнения:  
    - IntroSort — стабильно в пределах до 10 мс, практически не увеличивается с ростом массива.  
    - QuickSort — превышает 200 мс при больших размерах массива, причём время непрерывно растёт.  
- Причины:  
  - Для стандартного QuickSort обратно отсортированный массив представляет худший случай: на каждом шаге массив делится неравномерно, рекурсия уходит на максимальную глубину \(O(N^2)\).  
  - В IntroSort при достижении критической глубины рекурсии (\(2 \log_2 N\)) выполняется переключение на HeapSort, который в худшем случае имеет сложность \(O(N \log N)\), предотвращая экспоненциальный рост времени.  
- Вывод:  
  - В задачах с обратно отсортированными данными гибридный IntroSort явно эффективнее стандартного QuickSort, так как он избегает его худшего случая.  

#### 3. Исследование на почти отсортированных данных  
- Результаты:  
  - На почти отсортированных массивах с небольшими перестановками:  
    - IntroSort стабильно выполняется за до 7 мс и практически не демонстрирует роста времени.  
    - QuickSort показывает значительно большее время — до 175 мс, с флуктуациями в производительности.  
- Причины:  
  - Стандартный QuickSort даже при случайном выборе пивота может сталкиваться с неравномерными разбиениями массива, что влечёт значительный рост времени.  
  - IntroSort, благодаря использованию InsertionSort для мелких подмассивов, эффективно обрабатывает почти отсортированные данные, где сложность близка к \(O(N)\).  
- Вывод:  
  - На почти отсортированных данных гибридный IntroSort снова демонстрирует явное преимущество, минимизируя влияние сложных разбиений.  

### Заключение  
   Гибридный IntroSort показывает лучшее время работы для массивов с худшими случаями (обратно отсортированные, почти отсортированные). При этом на случайных данных его эффективность сопоставима с QuickSort.  
